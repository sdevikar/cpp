# Lambda Expressions

## Background

In C, it's common to use function pointers to achieve sort of a customizable behavior for a function. e.g. we can write a sort function that can sort integers as well as strings, as long as we pass it a function that's able to provide implementation for the `<` operator for a given datatype.

There are a couple of problems with this approach:

- compiler cannot optimize the code with function pointer regardless of the optimization level because the function pointer is simply a pointer to a memory location, so it cannot be inlined.
- a function pointed to by a function pointer cannot have a state, so it can't make use of stored data, etc.
- even though function pointer approach sounds generic, it really isn't. We can only templatize the function calling the function pointer so much and at some point, we'll have to start providing custom comparators. e.g. maybe we can provide comparators as args for strings with specialized template, but what about the user defined objects? We'll have to start writing comparators for every type in global scope.

## Lambda expression concept

C++11 introduced lambda expressions as a replacement for function objects (functors). Lambda expressions are nameless function objects with the following syntax. Lambda expressions behave just like functions. i.e. they accept arguments and return a value.

```cpp
// lambda expression syntax
[](<args>) <mutable> <exception specification> -> <return type>
{
    // implementation goes here
}

// lambda expression can be invoked using () operator
[](){

    std::cout << "Invoked lambda expression" << std::endl;
}(); // notice the () operator here

// we can create a named lambda expression as below.
// notice the use of auto keyword, since we don't really know the function signature

auto lambda_function = [](){

    std::cout << "Invoked named lambda expression" << std::endl;
};

// invoke lambda function:
lambda_function(); // should print "Invoked named lambda function"

// print the typeid of lambda function
// this should print class<lambda_autogeneratedid>, meaning that
// the lambda function is a class of type lambda_<id>, where id is some autogenerated number
std::cout << typeid(lambda_function) << std::endl;
```

In the above syntax:

- [] is lambda introducer. i.e. it marks the start of lambda expression and contains something called as "capture clause"
- `<args>` optional args
- `<mutable>` whether or not lambda expression can modify its copies of the external variables
- `<exception specifications>`
- `<return type>` at the end it called the trailing return type

- Internally, for lambda expression, the compiler creates an anonymous class and overrides `()` operator in it.
- The compiler also synthesizes a static conversion operator in this anonymous class which returns a function pointer to `()`. This is to allow the lambda expression to "decay" to a function pointer, so it can be invoked within the C code.

### Basic lambda expression examples

```cpp

// lambda expression to add two values
// notice here, that we haven't specified return value
// since there's only one return statement here, it is inferred to int
auto sum = [](int x, int y){
    return x+y;
};

// the above is equivalent to
auto sum = [](int x, int y)-> int{
    return x+y;
};

// however, the following will not compile without a return type because of different
// inferred datatypes at different return statements
auto sum = [](int x, int y){
    if(x < 0){
        return 0.5; // this is returning double
    }
    return x+y; // this is returning int
};

// we can fix the above by specifying double type as return type
auto sum = [](int x, int y)-> double{
    if(x < 0){
        return 0.5; // this is returning double
    }
    return x+y; // this will be upcasted to double from int
};

```

## Generic lambda (C++14) feature

Since we can templatize a class or a function, this is also possible with lambda expressions. All we need to do is instead of specifying explicit dataype in lambda expression arguments, we can provide the "auto" keyword as below:

```cpp
// generic lambda expression

auto sum = [](auto x, auto y){
    return x+y; // this is returning int
};

// usage

sum<int> s1;
s(5,6);

sum<double> s2;
s(5.4,6.3);
```

Now we can invoke this sum function with any datatype that has an implementation for `+` operator

### lambda expression with/without exception

We can explicitly specify that the lambda expression doesn't throw any exception as below:

```cpp
// no exception thrown
auto sum = [](auto x, auto y)noexcept{
    return x+y; // this is returning int
};

// exception can be thrown
auto sum = [](auto x, auto y)noexcept(false){
    return x+y; // this is returning int
};
```

## Capture list

### Some background concepts

Since lambda expressions are implemented as anonymous function objects internally, we can pass them to a function as an object, similar to what we do with comparators. So, for example, we can pass it to a sort function as a comparator that knows how to implement `<` operation for strings, for example.
There's a couple of advantages of doing things with lambda expression this way, as opposed to traditional function object or function pointer:

1. Reader immediately knows what the comparator is doing (e.g. see code below)
2. We don't end up polluting global namespace with functions or functors

```cpp

// Sort algorithm implementation
template <typename T, int size, typename Comparator>
void MySortAlgorithm(T& arr[size], Comparator comp){
    //... sort algorithm implementation goes here
}

// passing lambda expression as a comparator
// array - input array that needs sorting
// arg2: lambda expression that implements comparator
MySortAlgorithm(array, [](auto x, auto y){ return x > y ;});
```

Another example of lambda usage is foreach type lambda iterators. See example below:

```cpp

template<typename T, int size, typename I>
void ForEach(T& arr[size], I it){
    for(int i = 0; i < size; i++){
        it(arr[i]);
    }
}

int arr[]{1,2,3,4,5};

// we pass the lambda expression that simply prints the value
// i.e. the lambda expression here just knows how to print the element
// this is then used by ForEach above to print elements as it iterates over them
// This way, we have outsourced iteration over the array
// and we can pass a different lambda expression that knows how to print other datatypes
ForEach(arr, [](auto x){
    std::cout << x << std::endl;
});
```

### Capturing a variable in a capture list (Part 1)

Let's say in the ForEach example above, we want to add an offset to each element of the array. instead of just printing it. We can do this as follows:

```cpp
int offset = 5;

ForEach(arr, [offset](auto& x){
    x +=offset;
    std::cout << x << std::endl;
});
```

- Notice that even though offset was declared and defined in the same scope above the lambda expression , it is _not accessible to the lambda expression_ unless its name is passed in the capture list.
- In this case `offset` is passed to the capture list of the lamda by value. i.e. the offset inside the lambda expression is different than the one defined above.
- Also by default, the offset passed here to the lambda expression is immutable inside the lambda expression. This is because the anonymous function object that compiler generates for the lambda expression implements `()` operator as a const function. See below:
- In order for the lambda expression to see the variable in the capture list, _it must be declared before the lambda expression_
- We do not need to pass static and global variables to lambda expression's capture list

```cpp
// compiler generated functor for lambda expression
struct __Unnamed{
    int offset; // variable is created for captured variables

    __Unnamed(int offset): offset(offset){

    }

    void operator()(T &x) const{
        // whatever logic is within {} for lambda expression
        // notice that this is a const function
        // and therefore won't be able to modify offset
    }
}
```

In order for the capture list arguments to be mutable, when it is passed by value, we have to specify `mutable` kwyword as below:

```cpp
ForEach(arr, [offset](auto& x) mutable{
    x +=offset;
    std::cout << x << std::endl;
});
```

In all of the above examples, we captured the argument to the lambda expression by value. But it is also possible to pass the argument to lambda expression by reference. Here's how:

```cpp
int arr[] = {1,2,3,4,5};
int sum = 0;
int offset = 0;

// lambda expression is capturing two variables, one by reference and one by value
// no mutable keyword is requried to manipulate the argument passed by reference
ForEach(arr, [&sum, offset](auto& x) {
    sum +=x;
});

std::cout << "sum of all elements of an array" >> sum << std::endl; // will print 15
```

This will work because the sum is captured by lambda expression by reference. In this case, mutable keyword is no longer required.

- If we wanted to collect all args by reference, we can simply do this:

```cpp
// notice the use of [&]
// all args are captured by reference
ForEach(arr, [&](auto& x) {
    sum +=x;
    offset += 1; // now offset can be modified too
});
```

- If we wanted to collect all args by value, we can do this:

```cpp
// notice the use of [=]
// all args are captured by value
ForEach(arr, [=](auto& x) {
    sum +=x; // now this is illegal
    offset += 1; // now this is illegal
});
```

- we can also explicitly specify what variable gets captured by value or reference

```cpp
// notice the use of [=, &sum]
// all args except sum are captured by value
ForEach(arr, [=, &sum](auto& x) {
    sum +=x; // this is legal
    offset += 1; // now this is illegal
});
```

- If we're using lambda expression within a class member function, we can pass `this` to capture all member variables

```cpp
// notice the use of [this]
// all class member variables can now be captured
ForEach(arr, [this](auto& x) {
    // do something with class member variable here
    //e.g.
    x = x+ myclassmembervariable;
});
```

Note that the individual class member variables cannot be captured like we captured local variables by value and reference. We have to use this.

### Nested lambda expressions

- We can nest lambda expressions. e.g.

```cpp

//outer lambda expression:
[](int x){
    x*=2; // 5*2
    // inner lambda expression
    [](int x){
        std::cout << x << std::endl; // 10
    }(x)
}(5); // call outer lambda expression with arg = 5

```

### Lambda expression as a function pointer (for C language)

A Lambda expression with an empty capture list automatically decomposes to a function pointer. i.e. it can be used within a C program. e.g.

```cpp
int main(void)
{
    // atexit is a c function
    atexit([](){ // note the empty capture list
        printf("exiting...");
    });
    return 0;
}
```

This works because for lambda expression with an empty capturelist, compiler generates a type conversion operator. This point conversion operator returns a pointer to function. And the pointer is pointing to an internal static member function inside the lambda expression. And this function internally invokes the `()` operator

### Generalized lambda captures C++14

- Generalized capture allows for the creation of new variables inside the capute clause (think `for(int i = 0;...)` where i is created inside the for loop braces). The syntax is:

```cpp
// create a variable var
[var = expression](args){...};

// create a reference to variable var
[&var = expression](args){...};
```

Here's a trivial example:

```cpp
int x = 5;

auto myexp = [y=x](double offset){
    return y + offset;
}

myexp(0.1);  // answer = 5.1
```

- Notice that in the above example, the type of variables `y` is deduced from the type of `x`. In general, since we don't need to specify the datatype of `y` we need to initialize the variables created in the generalized capture list with some value, so the type can be deduced automatically. (e.g. `y = 0.0` would be double, `y = 0` would be int and so on)

### Why generalized lambda capture

Earlier we saw that:

- capture list allows for making an outer scope variable available to lambda expression. By default it's not modifiable
- to modify, we can do the lambda capture by reference or
- we can make lambda mutable

So, if all of the above possible, why create a new variable in the capture list?

This has to do with the scope. Sometimes, we may need a variable that's used only inside the lambda expression and thereafter, there's no use for it. e.g. consider the following for writing to a file:

```cpp
std::ofstream outfilestream("file.txt");
std::string content = "some content";

// lambda expression to write something to the file
auto filewrite = [&outfilestream](std::string content) {
    outfilestream << content;
}

// invoke lambda expression
filewrite(content);
```

The above code works. But as we can see, outfilestream is still available for the code that might follow. So, instead, we can do the following:

```cpp

// lambda expression to write something to the file
// notice the use of std::move, making outfilestream inaccesible later
// and mutable makes `os` writable
auto filewrite = [os = std::move(outfilestream)](std::string content) mutable{
    os << content;
}

// invoke lambda expression
filewrite(content);
```
